"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = __importDefault(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const index_1 = require("../index");
const fetch_mock_1 = __importDefault(require("fetch-mock"));
const events_1 = require("../src/events");
const sinon_1 = __importDefault(require("sinon"));
chai_1.default.use(chai_as_promised_1.default);
const expect = chai_1.default.expect;
const sampleRequestData = {
    event: events_1.EVENTS.LOGIN_SUCCEEDED,
    created_at: 'now',
    user_id: 'userid',
    user_traits: {
        email: 'myemail',
        registered_at: 'today',
    },
    context: {
        ip: '8.8.8.8',
        client_id: 'clientid',
        headers: {
            Cookie: 'SECRET=pleasedontbehere',
        },
    },
};
describe('Castle', () => {
    it('should have some public methods', () => {
        const castle = new index_1.Castle({ apiSecret: 'some secret' });
        expect(castle).to.have.property('authenticate');
        expect(castle).to.have.property('track');
    });
    it('should throw if API secret is missing', () => {
        const castleFactory = () => new index_1.Castle({});
        expect(castleFactory).to.throw();
    });
    describe('track', () => {
        it('should make a network request with some basic information', () => {
            const fetch = fetch_mock_1.default.sandbox().post('*', 204);
            const clock = sinon_1.default.useFakeTimers(new Date(2011, 9, 1).getTime());
            const castle = new index_1.Castle({
                apiSecret: 'some secret',
                overrideFetch: fetch,
            });
            castle.track(sampleRequestData);
            const lastOptions = fetch.lastOptions();
            const payload = JSON.parse(lastOptions.body.toString());
            expect(payload).to.have.property('sent_at', new Date().toISOString());
            expect(payload).to.have.property('event', sampleRequestData.event);
            expect(payload).to.have.property('created_at', sampleRequestData.created_at);
            expect(payload).to.have.property('event', sampleRequestData.event);
            expect(payload).to.have.property('user_id', sampleRequestData.user_id);
            expect(payload).to.have.property('user_traits');
            expect(payload.user_traits).to.have.property('email', sampleRequestData.user_traits.email);
            expect(payload.user_traits).to.have.property('registered_at', sampleRequestData.user_traits.registered_at);
            expect(payload).to.have.property('context');
            expect(payload.context).to.have.property('ip', sampleRequestData.context.ip);
            expect(payload.context).to.have.property('client_id', sampleRequestData.context.client_id);
            expect(payload.context).to.have.property('headers');
            expect(payload.context.headers).to.have.property('Cookie', true);
            clock.restore();
        });
        it('should only allow whitelisted headers', () => {
            const fetch = fetch_mock_1.default.sandbox().post('*', 204);
            const castle = new index_1.Castle({
                apiSecret: 'some secret',
                overrideFetch: fetch,
                allowedHeaders: ['X-NOT-A-SECRET'],
            });
            castle.track(Object.assign({}, sampleRequestData, { context: Object.assign({}, sampleRequestData.context, { headers: {
                        'X-NOT-A-SECRET': 'not secret!',
                        'X-SUPER-SECRET': 'so secret!',
                    } }) }));
            const lastOptions = fetch.lastOptions();
            const payload = JSON.parse(lastOptions.body.toString());
            expect(payload).to.have.property('context');
            expect(payload.context).to.have.property('headers');
            expect(payload.context.headers).to.have.property('X-NOT-A-SECRET', 'not secret!');
            expect(payload.context.headers).to.have.property('X-SUPER-SECRET', true);
        });
        it('should not allow blacklisted headers', () => {
            const fetch = fetch_mock_1.default.sandbox().post('*', 204);
            const castle = new index_1.Castle({
                apiSecret: 'some secret',
                overrideFetch: fetch,
                disallowedHeaders: ['X-SUPER-SECRET'],
            });
            castle.track(Object.assign({}, sampleRequestData, { context: Object.assign({}, sampleRequestData.context, { headers: {
                        'X-NOT-A-SECRET': 'not secret!',
                        'X-SUPER-SECRET': 'so secret!',
                    } }) }));
            const lastOptions = fetch.lastOptions();
            const payload = JSON.parse(lastOptions.body.toString());
            expect(payload).to.have.property('context');
            expect(payload.context).to.have.property('headers');
            expect(payload.context.headers).to.have.property('X-NOT-A-SECRET', 'not secret!');
            expect(payload.context.headers).to.have.property('X-SUPER-SECRET', true);
        });
        it('should not do requests when do not track is set', () => __awaiter(this, void 0, void 0, function* () {
            const fetch = fetch_mock_1.default.sandbox().post('*', 500);
            const castle = new index_1.Castle({
                apiSecret: 'some secret',
                overrideFetch: fetch,
                doNotTrack: true,
                failoverStrategy: 'deny',
            });
            yield castle.track(sampleRequestData);
            expect(fetch.called()).to.be.false;
        }));
        it('should fail on unauthorized', () => __awaiter(this, void 0, void 0, function* () {
            const fetch = fetch_mock_1.default.sandbox().post('*', 401);
            const castle = new index_1.Castle({
                apiSecret: 'some secret',
                overrideFetch: fetch,
            });
            yield expect(castle.authenticate(sampleRequestData)).to.be.rejectedWith(/Castle: Failed to authenticate with API, please verify the secret./);
        }));
    });
    describe('authenticate', () => {
        it('should make a network request with some basic information', () => __awaiter(this, void 0, void 0, function* () {
            const fetch = fetch_mock_1.default.sandbox().mock('*', { action: 'allow', device_token: 'device_token', user_id: 'user_id' });
            const clock = sinon_1.default.useFakeTimers(new Date(2011, 9, 1).getTime());
            const castle = new index_1.Castle({
                apiSecret: 'some secret',
                overrideFetch: fetch,
            });
            const response = yield castle.authenticate(sampleRequestData);
            expect(response).to.have.property('action', 'allow');
            expect(response).to.have.property('device_token', 'device_token');
            expect(response).to.have.property('user_id', 'user_id');
            const lastOptions = fetch.lastOptions();
            const payload = JSON.parse(lastOptions.body.toString());
            expect(payload).to.have.property('sent_at', new Date().toISOString());
            expect(payload).to.have.property('event', sampleRequestData.event);
            expect(payload).to.have.property('created_at', sampleRequestData.created_at);
            expect(payload).to.have.property('user_id', sampleRequestData.user_id);
            expect(payload).to.have.property('user_traits');
            expect(payload.user_traits).to.have.property('email', sampleRequestData.user_traits.email);
            expect(payload.user_traits).to.have.property('registered_at', sampleRequestData.user_traits.registered_at);
            expect(payload).to.have.property('context');
            expect(payload.context).to.have.property('ip', sampleRequestData.context.ip);
            expect(payload.context).to.have.property('client_id', sampleRequestData.context.client_id);
            expect(payload.context).to.have.property('headers');
            expect(payload.context.headers).to.have.property('Cookie', true);
            clock.restore();
        }));
        it('should handle timeout', () => __awaiter(this, void 0, void 0, function* () {
            const abortError = new Error();
            abortError.name = 'AbortError';
            abortError.message = 'The request was aborted.';
            const fetch = fetch_mock_1.default.sandbox().post('*', { throws: abortError });
            const castle = new index_1.Castle({
                apiSecret: 'some secret',
                overrideFetch: fetch,
                failoverStrategy: 'deny',
                logLevel: 'fatal',
            });
            const response = yield castle.authenticate(sampleRequestData);
            expect(response).to.have.property('action', 'deny');
            expect(response).to.have.property('failover', true);
            expect(response).to.have.property('failover_reason', 'timeout');
            expect(response).to.have.property('user_id', 'userid');
        }));
        it('should failover on 500', () => __awaiter(this, void 0, void 0, function* () {
            const fetch = fetch_mock_1.default.sandbox().post('*', 500);
            const castle = new index_1.Castle({
                apiSecret: 'some secret',
                overrideFetch: fetch,
                failoverStrategy: 'deny',
                logLevel: 'fatal',
            });
            const response = yield castle.authenticate(sampleRequestData);
            expect(response).to.have.property('action', 'deny');
            expect(response).to.have.property('failover', true);
            expect(response).to.have.property('failover_reason', 'server error');
            expect(response).to.have.property('user_id', 'userid');
        }));
        it('should failover when do not track is set', () => __awaiter(this, void 0, void 0, function* () {
            const fetch = fetch_mock_1.default.sandbox().post('*', 500);
            const castle = new index_1.Castle({
                apiSecret: 'some secret',
                overrideFetch: fetch,
                doNotTrack: true,
                failoverStrategy: 'deny',
            });
            const response = yield castle.authenticate(sampleRequestData);
            expect(response).to.have.property('action', 'deny');
            expect(response).to.have.property('failover', true);
            expect(response).to.have.property('failover_reason', 'do not track');
            expect(response).to.have.property('user_id', 'userid');
            expect(fetch.called()).to.be.false;
        }));
        it('should fail on unauthorized', () => __awaiter(this, void 0, void 0, function* () {
            const fetch = fetch_mock_1.default.sandbox().post('*', 401);
            const castle = new index_1.Castle({
                apiSecret: 'some secret',
                overrideFetch: fetch,
            });
            yield expect(castle.authenticate(sampleRequestData)).to.be.rejectedWith(/Castle: Failed to authenticate with API, please verify the secret./);
        }));
    });
});
//# sourceMappingURL=Castle.test.js.map