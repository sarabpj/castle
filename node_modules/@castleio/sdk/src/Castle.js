"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = __importDefault(require("node-fetch"));
const lodash_1 = require("lodash");
const abort_controller_1 = __importDefault(require("abort-controller"));
const package_json_1 = __importDefault(require("../package.json"));
const pino_1 = __importDefault(require("pino"));
const defaultApiUrl = 'https://api.castle.io';
const getBody = (response) => __awaiter(this, void 0, void 0, function* () {
    if (response.cachedBody) {
        return response.cachedBody;
    }
    try {
        response.cachedBody = yield response.json();
    }
    catch (e) {
        response.cachedBody = {};
    }
    return response.cachedBody;
});
const isTimeout = (e) => e.name === 'AbortError';
const errorFormatter = (err) => `
Error name: ${err.name}
Error message: ${err.message}
`.trim();
const responseFormatter = (response, body) => `
Response status: ${response.status}
Response body: ${JSON.stringify(body)}
`.trim();
const requestFormatter = ({ requestUrl, requestOptions, response, err, body, }) => `
-- Castle request
URL: ${requestUrl}
Request: ${JSON.stringify(requestOptions)}
-- Castle response
${response ? responseFormatter(response, body) : errorFormatter(err)}
`;
class Castle {
    constructor({ apiSecret, apiUrl, timeout = 750, allowedHeaders = [], disallowedHeaders = [], overrideFetch = node_fetch_1.default, failoverStrategy = 'allow', logLevel = 'error', doNotTrack = false, }) {
        if (!apiSecret) {
            throw new Error('Castle: Unable to instantiate Castle client, API secret is missing.');
        }
        this.apiSecret = apiSecret;
        this.apiUrl = apiUrl || defaultApiUrl;
        this.timeout = timeout;
        this.allowedHeaders = allowedHeaders.map(x => x.toLowerCase());
        this.disallowedHeaders = disallowedHeaders
            .concat(['cookie'])
            .map(x => x.toLowerCase());
        this.overrideFetch = overrideFetch;
        this.failoverStrategy = failoverStrategy;
        this.logger = pino_1.default({
            prettyPrint: {
                levelFirst: true,
            },
        });
        this.logger.level = logLevel;
        this.doNotTrack = doNotTrack;
    }
    authenticate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!params.event) {
                throw new Error('Castle: event is required when calling authenticate.');
            }
            if (this.doNotTrack) {
                return this.generateFailoverBody(params, 'do not track');
            }
            let response;
            const controller = new abort_controller_1.default();
            const timeout = setTimeout(() => {
                controller.abort();
            }, this.timeout);
            const requestUrl = `${this.apiUrl}/v1/authenticate`;
            const requestOptions = {
                signal: controller.signal,
                method: 'POST',
                headers: this.generateDefaultRequestHeaders(),
                body: this.generateRequestBody(params),
            };
            try {
                response = yield this.getFetch()(requestUrl, requestOptions);
            }
            catch (err) {
                this.handleLogging({ requestUrl, requestOptions, err });
                if (isTimeout(err)) {
                    return this.handleFailover(params, 'timeout', err);
                }
                else {
                    throw err;
                }
            }
            finally {
                clearTimeout(timeout);
            }
            const body = yield getBody(response);
            this.handleLogging({ requestUrl, requestOptions, response });
            if (response.status >= 500) {
                return this.handleFailover(params, 'server error');
            }
            this.handleUnauthorized(response);
            this.handleBadResponse(response);
            return body;
        });
    }
    track(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!params.event) {
                throw new Error('Castle: event is required when calling track.');
            }
            if (this.doNotTrack) {
                return;
            }
            let response;
            const controller = new abort_controller_1.default();
            const timeout = setTimeout(() => {
                controller.abort();
            }, this.timeout);
            const requestUrl = `${this.apiUrl}/v1/track`;
            const requestOptions = {
                signal: controller.signal,
                method: 'POST',
                headers: this.generateDefaultRequestHeaders(),
                body: this.generateRequestBody(params),
            };
            try {
                response = yield this.getFetch()(requestUrl, requestOptions);
            }
            catch (err) {
                if (isTimeout(err)) {
                    return this.handleLogging({ requestUrl, requestOptions, err });
                }
            }
            finally {
                clearTimeout(timeout);
            }
            this.handleLogging({ requestUrl, requestOptions, response });
            this.handleUnauthorized(response);
            this.handleBadResponse(response);
        });
    }
    handleLogging({ requestUrl, requestOptions, response, err, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (err) {
                return this.logger.error(requestFormatter({ requestUrl, requestOptions, err }));
            }
            let body;
            if (response.status !== 204) {
                body = yield getBody(response);
            }
            let log;
            if (response.ok) {
                log = this.logger.info.bind(this.logger);
            }
            else if (response.status < 500 && response.status >= 400) {
                log = this.logger.warn.bind(this.logger);
            }
            else {
                log = this.logger.error.bind(this.logger);
            }
            return log(requestFormatter({ requestUrl, requestOptions, response, err, body }));
        });
    }
    getFetch() {
        return this.overrideFetch || node_fetch_1.default;
    }
    scrubHeaders(headers) {
        return lodash_1.reduce(headers, (accumulator, value, key) => {
            if (this.disallowedHeaders.includes(key.toLowerCase())) {
                return Object.assign({}, accumulator, { [key]: true });
            }
            if (this.allowedHeaders.length &&
                !this.allowedHeaders.includes(key.toLowerCase())) {
                return Object.assign({}, accumulator, { [key]: true });
            }
            return Object.assign({}, accumulator, { [key]: value });
        }, {});
    }
    generateDefaultRequestHeaders() {
        return {
            Authorization: `Basic ${Buffer.from(`:${this.apiSecret}`).toString('base64')}`,
            'Content-Type': 'application/json',
        };
    }
    generateRequestBody({ event, user_id, user_traits, properties, context, created_at, device_token, }) {
        return JSON.stringify({
            sent_at: new Date().toISOString(),
            created_at,
            event,
            user_id,
            user_traits,
            properties,
            device_token,
            context: Object.assign({}, context, { client_id: context.client_id || false, headers: this.scrubHeaders(context.headers), library: {
                    name: 'castle-node',
                    version: package_json_1.default.version,
                } }),
        });
    }
    generateFailoverBody(params, reason) {
        return {
            action: this.failoverStrategy === 'none' ? 'allow' : this.failoverStrategy,
            failover: true,
            failover_reason: reason,
            user_id: params.user_id,
        };
    }
    handleFailover(params, reason, err) {
        if (this.failoverStrategy !== 'none') {
            return this.generateFailoverBody(params, reason);
        }
        if (this.failoverStrategy === 'none') {
            throw err;
        }
    }
    handleUnauthorized(response) {
        if (response.status === 401) {
            throw new Error('Castle: Failed to authenticate with API, please verify the secret.');
        }
    }
    handleBadResponse(response) {
        if (response.status >= 400 && response.status < 500) {
            throw new Error(`Castle: API response not ok, got ${response.status}.`);
        }
    }
}
exports.Castle = Castle;
//# sourceMappingURL=Castle.js.map